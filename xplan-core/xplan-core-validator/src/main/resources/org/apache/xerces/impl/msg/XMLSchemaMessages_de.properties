###
# #%L
# xplan-validator-core - XPlan Validator Core Komponente
# %%
# Copyright (C) 2008 - 2024 Freie und Hansestadt Hamburg, developed by lat/lon gesellschaft für raumbezogene Informationssysteme mbH
# %%
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# #L%
###
# This file contains error and warning messages related to XML Schema
# Translation based on the german xerces impl jar: http://www.java2s.com/Code/Jar/x/DownloadxercesImpldejar.htm

BadMessageKey = Die zur Meldungs-ID geh\u00f6rende Fehlermeldung kann nicht gefunden werden.
FormatFailed = Beim Formatieren der folgenden Meldung ist ein interner Fehler aufgetreten:\n
# For internal use
Internal-Error = Interner Fehler: {0}.
dt-whitespace = Kein Leerraum-Fassettenwert f\u00fcr den einfachen Vereinigungstyp \u201e{0}\u201c verf\u00fcgbar.
GrammarConflict = Eine der Grammatiken, die aus dem Grammatikpool des Benutzers zur\u00fcckgegeben wurde, konfligiert mit einer anderen Grammatik.

# Identity constraints
AbsentKeyValue = cvc-identity-constraint.4.2.1.a: Element "{0}" hat keinen Wert f\u00FCr den Schl\u00FCssel "{1}".
DuplicateField = Doppelte Entsprechung im Bereich f\u00fcr Feld \u201e{0}\u201c.
DuplicateKey = cvc-identity-constraint.4.2.2: Doppelter Schl\u00FCsselwert [{0}] f\u00FCr ID-Constraint "{2}" des Elements "{1}" deklariert.
DuplicateUnique = cvc-identity-constraint.4.1: Doppelter eindeutiger Wert [{0}] f\u00FCr ID-Constraint "{2}" des Elements "{1}" deklariert.
FieldMultipleMatch = cvc-identity-constraint.3: Feld "{0}" von ID-Constraint "{1}" entspricht mehr als einem Wert im Bereich seines Selektors; Felder m\u00FCssen eindeutigen Werten entsprechen.
FixedDiffersFromActual = Der Inhalt dieses Elements ist nicht \u00e4quivalent mit dem Wert des Attributs \u201efixed\u201c in der Elementdeklaration im Schema.
KeyMatchesNillable = cvc-identity-constraint.4.2.3: Element "{0}" hat den Schl\u00FCssel "{1}", der einem Element entspricht, bei dem "nillable" auf "true" gesetzt ist.
KeyNotEnoughValues = cvc-identity-constraint.4.2.1.b: Nicht gen\u00FCgend Werte f\u00FCr <key name=\"{1}\">-ID-Constraint f\u00FCr Element "{0}" angegeben.
KeyNotFound = cvc-identity-constraint.4.3: Schl\u00FCssel "{0}" mit Wert "{1}" f\u00FCr ID-Constraint des Elements "{2}" nicht gefunden.
KeyRefOutOfScope = ID-Constraint-Fehler: ID-Constraint \u201e{0}\u201c hat eine keyref, die sich auf einen Schl\u00fcssel oder einen eindeutigen Wert bezieht, der au\u00dferhalb des g\u00fcltigen Bereichs liegt.
KeyRefReferNotFound = Schl\u00fcsselreferenzdeklaration \u201e{0}\u201c bezieht sich auf unbekannten Schl\u00fcssel mit dem Namen \u201e{1}\u201c.
UnknownField = Interner ID-Constraint-Fehler; unbekanntes Feld "{0}" bei ID-Constraint "{2}" f\u00FCr Element "{1}" angegeben.

# Ideally, we should only use the following error keys, not the ones under
# "Identity constraints". And we should cover all of the following errors.
# validation (3.X.4)
cvc-attribute.3 = cvc-attribute.3: Der Wert "{2}" des Attributs "{1}" in Element "{0}" ist im Hinblick auf seinen Typ ("{3}") nicht g\u00FCltig.
cvc-attribute.4 = cvc-attribute.4: Der Wert "{2}" des Attributs "{1}" in Element "{0}" ist im Hinblick auf die Vorgabe "{''value constraint''}" nicht g\u00FCltig. Das Attribut muss den Wert "{3}" aufweisen.
cvc-complex-type.2.1 = cvc-complex-type.2.1: Element "{0}" darf keine Zeichen- oder Elementinformationsobjekte [children] haben, da der Inhaltstyp des Typs leer ist.
cvc-complex-type.2.2 = cvc-complex-type.2.2: Element "{0}" darf keine Elemente [children] haben und der Wert muss g\u00FCltig sein.
cvc-complex-type.2.3 = cvc-complex-type.2.3: Element "{0}" darf keine Zeichen [children] haben, da der Inhaltstyp des Typs "nur Elemente" ist.
cvc-complex-type.2.4.a = cvc-complex-type.2.4.a: Ung\u00FCltiger Inhalt beginnend mit Element "{0}" gefunden. Inhalt "{1}" wird erwartet.
cvc-complex-type.2.4.b = cvc-complex-type.2.4.b: Der Inhalt des Elements "{0}" ist nicht vollst\u00E4ndig. Inhalt "{1}" wird erwartet.
cvc-complex-type.2.4.c = cvc-complex-type.2.4.c: Der entsprechende Platzhalter ist "strict", es wurde jedoch keine Deklaration f\u00FCr Element "{0}" gefunden.
cvc-complex-type.2.4.d = cvc-complex-type.2.4.d: Ung\u00FCltiger Inhalt beginnend mit Element "{0}" gefunden. Hier wird kein untergeordnetes Element erwartet.
cvc-complex-type.3.1 = cvc-complex-type.3.1: Wert "{2}" von Attribut "{1}" des Elements "{0}" ist im Hinblick auf die entsprechende Attributverwendung nicht g\u00FCltig. Attribut "{1}" hat den vorgegebenen Wert "{3}".
cvc-complex-type.3.2.1 = cvc-complex-type.3.2.1: Element "{0}" hat keinen Attributplatzhalter f\u00FCr Attribut "{1}".
cvc-complex-type.3.2.2 = cvc-complex-type.3.2.2: Attribut "{1}" darf in Element "{0}" nicht vorhanden sein.
cvc-complex-type.4 = cvc-complex-type.4: Attribut "{1}" muss in Element "{0}" stehen.
cvc-complex-type.5.1 = cvc-complex-type.5.1: Attribut "{1}" in Element "{0}" ist eine Platzhalter-ID. Es gibt jedoch bereits eine Platzhalter-ID: "{2}". Es ist nur eine erlaubt.
cvc-complex-type.5.2 = cvc-complex-type.5.2: Attribut "{1}" in Element "{0}" ist eine Platzhalter-ID. Es ist jedoch bereits ein Attribut "{2}" vorhanden, das von einer ID gem\u00E4\u00DF "{''attribute uses''}" abgeleitet wurde.
cvc-datatype-valid.1.2.1 = cvc-datatype-valid.1.2.1: "{0}" ist kein g\u00FCltiger Wert f\u00FCr "{1}".
cvc-datatype-valid.1.2.2 = cvc-datatype-valid.1.2.2: "{0}" ist kein g\u00FCltiger Wert des Listentyps "{1}".
cvc-datatype-valid.1.2.3 = cvc-datatype-valid.1.2.3: "{0}" ist kein g\u00FCltiger Wert des Vereinigungstyps "{1}".
cvc-elt.1 = cvc-elt.1: Deklaration des Elements "{0}" wurde nicht gefunden.
cvc-elt.2 = cvc-elt.2: Der Wert von "{''abstract''}" in der Elementdeklaration f\u00FCr "{0}" muss "false" sein.
cvc-elt.3.1 = cvc-elt.3.1: Attribut "{1}" darf nicht in Element "{0}" stehen, da die Eigenschaft "{''nillable''}" von "{0}" "false" ist.
cvc-elt.3.2.1 = cvc-elt.3.2.1: Element "{0}" darf keine Zeichen- oder Elementinformationen [children] haben, da "{1}" angegeben ist.
cvc-elt.3.2.2 = cvc-elt.3.2.2: "''{''value constraint''}" f\u00FCr Element "{0}" darf nicht vorgegeben sein, da "{1}" angegeben ist.
cvc-elt.4.1 = cvc-elt.4.1: Der Wert "{2}" des Attributs "{1}" von Element "{0}" ist kein g\u00FCltiger QName.
cvc-elt.4.2 = cvc-elt.4.2: "{1}" kann nicht in eine Typdefinition f\u00FCr Element "{0}" aufgel\u00F6st werden.
cvc-elt.4.3 = cvc-elt.4.3: Typ "{1}" ist von der Typdefinition ("{2}") des Elements "{0}" nicht g\u00FCltig abgeleitet.
cvc-elt.5.1.1 = cvc-elt.5.1.1: "{''value constraint''}" "{2}" des Elements "{0}" ist kein g\u00FCltiger Standardwert f\u00FCr Typ "{1}".
cvc-elt.5.2.2.1 = cvc-elt.5.2.2.1: Element "{0}" darf keine Elementinformationsobjekte [children] haben.
cvc-elt.5.2.2.2.1 = cvc-elt.5.2.2.2.1: Der Wert "{1}" des Elements "{0}" entspricht nicht dem vorgegebenen "{''value constraint''}"-Wert "{2}".
cvc-elt.5.2.2.2.2 = cvc-elt.5.2.2.2.2: Der Wert "{1}" des Elements "{0}" entspricht nicht dem "{''value constraint''}"-Wert "{2}".
cvc-enumeration-valid = cvc-enumeration-valid: Wert "{0}" ist im Hinblick auf Enumeration "{1}" nicht Facetten-g\u00FCltig. Es muss ein Wert aus der Enumeration sein.
cvc-fractionDigits-valid = cvc-fractionDigits-valid: Wert "{0}" hat {1} Dezimalstellen, die Anzahl der Dezimalstellen wurde jedoch auf {2} beschr\u00E4nkt.
cvc-id.1 = cvc-id.1: Keine ID/IDREF-Bindung f\u00FCr IDREF "{0}" vorhanden.
cvc-id.2 = cvc-id.2: Der ID-Wert "{0}" kommt mehrmals vor.
cvc-id.3 = cvc-id.3: Ein Feld von ID-Constraint "{0}" entspricht Element "{1}", dieses Element hat jedoch keinen einfachen Typ.
cvc-length-valid = cvc-length-valid: Wert "{0}" mit L\u00E4nge "{1}" ist im Hinblick auf L\u00E4nge "{2}" f\u00FCr Typ "{3}" nicht Facetten-g\u00FCltig.
cvc-maxExclusive-valid = cvc-maxExclusive-valid: Wert "{0}" ist im Hinblick auf maxExclusive "{1}" f\u00FCr Typ "{2}" nicht Facetten-g\u00FCltig.
cvc-maxInclusive-valid = cvc-maxInclusive-valid: Wert "{0}" ist im Hinblick auf maxInclusive "{1}" f\u00FCr Typ "{2}" nicht Facetten-g\u00FCltig.
cvc-maxLength-valid = cvc-maxLength-valid: Wert "{0}" mit L\u00E4nge "{1}" ist im Hinblick auf maxLength "{2}" f\u00FCr Typ "{3}" nicht Facetten-g\u00FCltig.
cvc-minExclusive-valid = cvc-minExclusive-valid: Wert "{0}" ist im Hinblick auf minExclusive "{1}" f\u00FCr Typ "{2}" nicht Facetten-g\u00FCltig.
cvc-minInclusive-valid = cvc-minInclusive-valid: Wert "{0}" ist im Hinblick auf minInclusive "{1}" f\u00FCr Typ "{2}" nicht Facetten-g\u00FCltig.
cvc-minLength-valid = cvc-minLength-valid: Wert "{0}" mit length = "{1}" ist im Hinblick auf minLength "{2}" f\u00FCr Typ "{3}" nicht Facetten-g\u00FCltig.
cvc-pattern-valid = cvc-pattern-valid: Wert "{0}" ist im Hinblick auf Muster "{1}" f\u00FCr Typ "{2}" nicht Facetten-g\u00FCltig.
cvc-totalDigits-valid = cvc-totalDigits-valid: Wert "{0}" hat insgesamt {1} Stellen, die Gesamtzahl der Stellen wurde jedoch auf {2} eingeschr\u00E4nkt.
cvc-type.1 = cvc-type.1: Die Typdefinition "{0}" wurde nicht gefunden.
cvc-type.2 = cvc-type.2: Die Typdefinition f\u00FCr Element {0} darf nicht abstrakt sein.
cvc-type.3.1.1 = cvc-type.3.1.1: Element "{0}" ist ein einfacher Typ und darf daher keine Attribute haben. Eine Ausnahme hiervon bilden Elemente, deren Namespace-Name identisch mit "http://www.w3.org/2001/XMLSchema-instance" und bei denen [local name] entweder "type", "nil", "schemaLocation" oder "noNamespaceSchemaLocation" ist. Das Attribut "{1}" wurde jedoch nicht gefunden.
cvc-type.3.1.2 = cvc-type.3.1.2: Element "{0}" ist ein einfacher Typ und darf daher keine Elementinformationsobjekte [children] haben.
cvc-type.3.1.3 = cvc-type.3.1.3: Der Wert "{1}" des Elements "{0}" ist nicht g\u00FCltig.

# schema valid (3.X.3)
schema_reference.4 = schema_reference.4: Das Schemadokument \u201e{0}\u201c konnte nicht gelesen werden, weil 1) das Dokument nicht gefunden werden konnte 2) das Dokument nicht gelesen werden konnte; 3) das Wurzelelement des Dokuments nicht <xsd:schema> ist.
src-annotation = src-annotation: <annotation>-Elemente k\u00F6nnen nur <appinfo>- und <documentation>-Elemente enthalten; es wurde jedoch "{0}" gefunden.
src-attribute.1 = src-attribute.1: Die Eigenschaften "default" und "fixed" d\u00FCrfen nicht beide in der Attributdeklaration "{0}" enthalten sein. Verwenden Sie nur eine der beiden.
src-attribute.2 = src-attribute.2: : Die Eigenschaft "default" befindet sich im Attribut "{0}"; der Wert f\u00FCr "use" muss deshalb "optional" sein.
src-attribute.3.1 = src-attribute.3.1: In einer lokalen Attributdeklaration muss entweder "ref" oder "name" enthalten sein.
src-attribute.3.2 = src-attribute.3.2: Der Inhalt muss (annotation?) f\u00FCr die Attributreferenz "{0}" entsprechen.
src-attribute.4 = src-attribute.4: Attribut "{0}" hat sowohl ein "type"-Attribut als auch ein untergeordnetes "simpleType"-Element. Nur eines von beiden ist bei Attributen erlaubt.
src-attribute_group.2 = src-attribute_group.2: Die Schnittmenge der Platzhalter der Attributgruppe "{0}" kann nicht ausgedr\u00FCckt werden.
src-attribute_group.3 = src-attribute_group.3: Zirkeldefinitionen bei Attributgruppe "{0}" entdeckt. Wird den Attributgruppenverweisen rekursiv gefolgt, f\u00FChrt dies letztendlich wieder zur Attributgruppe zur\u00FCck.
src-ct.1 = src-ct.1: Komplexe Typdefinition. Repr\u00E4sentationsfehler bei Typ "{0}".  Wenn <complexContent> verwendet wird, muss der Basistyp ein komplexer Typ sein. "{1}" ist ein einfacher Typ.
src-ct.2.1 = src-ct.2.1: Komplexe Typdefinition. Repr\u00E4sentationsfehler bei Typ "{0}".  Wenn <simpleContent> verwendet wird, muss der Basistyp ein komplexer Typ sein, dessen Inhaltstyp einfach ist, oder (nur wenn eine Einschr\u00E4nkung festgelegt ist) ein komplexer Typ mit gemischtem Inhalt und leerbarem Partikel, oder (nur wenn eine Erweiterung spezifiziert ist) ein einfacher Typ. "{1}" erf\u00FCllt keine dieser Bedingungen.
src-ct.2.2 = src-ct.2.2: Komplexe Typdefinition. Repr\u00E4sentationsfehler bei Typ "{0}".  Wenn ein komplexer Typ mit einfachem Inhalt einen komplexen Typ mit gemischtem Inhalt und leerbarem Partikel einschr\u00E4nkt, muss sich unter den untergeordneten Elementen von <restriction> ein <simpleType> befinden.
src-ct.4 = src-ct.4: Komplexe Typdefinition. Repr\u00E4sentationsfehler bei Typ "{0}". Die Schnittmenge der Platzhalter kann nicht ausgedr\u00FCckt werden.
src-ct.5 = src-ct.5: Komplexe Typdefinition. Repr\u00E4sentationsfehler bei Typ "{0}". Die Vereinigung von Platzhaltern kann nicht ausgedr\u00FCckt werden.
src-element.1 = src-element.1: Die Eigenschaften "default" und "fixed" d\u00FCrfen nicht beide in der Elementdeklaration "{0}" enthalten sein. Verwenden Sie nur eine der beiden.
src-element.2.1 = src-element.2.1: : In einer lokalen Elementdeklaration muss entweder "ref" oder "name" enthalten sein.
src-element.2.2 = src-element.2.2: Da "{0}" das "ref"-Attribut enth\u00E4lt, muss sein Inhalt mit (annotation?)\u00FCbereinstimmen. Es wurde jedoch "{1}" gefunden.
src-element.3 = src-element.3: Das Element "{0}" hat sowohl ein Typattribut als auch ein untergeordnetes Element anonymen Typs. Nur eines der beiden ist bei Elementen erlaubt.
src-import.1.1 = src-import.1.1: Das Namespace-Attribut "{0}" eines <import>-Elementinformationsobjekts darf nicht gleich sein mit dem Ziel-Namespace des Schemas, in dem es sich befindet.
src-import.1.2 = src-import.1.2: Wenn sich das Namespace-Attribut nicht in einem <import>-Elementinformationsobjekt befindet, muss das enthaltende Schema einen Ziel-Namespace haben.
src-import.2 = src-import.2: Das Wurzelelement des Dokuments "{0}" muss den Namespace-Namen "http://www.w3.org/2001/XMLSchema" und den lokalen Namen "schema" haben.
src-import.3.1 = src-import.3.1: Das Namespace-Attribut "{0}" eines <import>-Elementinformationsobjekts muss identisch mit dem Ziel-Namespace-Attribut "{1}" des importierten Dokuments sein.
src-import.3.2 = src-import.3.2: Es wurde ein <import>-Elementinformationsobjekt gefunden, das kein Namespace-Attribut hat. Das importierte Dokument darf folglich kein Ziel-Namespace-Attribut haben. Im importierten Dokument wurde jedoch der Ziel-Namespace "{1}" gefunden.
src-include.1 = src-include.1: Das Wurzelelement des Dokuments "{0}" muss den Namespace-Namen "http://www.w3.org/2001/XMLSchema" und den lokalen Namen "schema" haben.
src-include.2.1 = src-include.2.1: Der Ziel-Namespace des referenzierten Schemas (momentan "{1}") muss identisch mit dem des enthaltenen Schemas (momentan "{0}") sein.
src-redefine.2 = src-redefine.2: Das Wurzelelement des Dokuments "{0}" muss den Namespace-Namen "http://www.w3.org/2001/XMLSchema" und den lokalen Namen "schema" haben.
src-redefine.3.1 = src-redefine.3.1: Der Ziel-Namespace des referenzierten Schemas (momentan "{1}") muss identisch mit dem des neu zu definierenden Schemas (momentan "{0}") sein.
src-redefine.5.a.a = src-redefine.5.a.a: Es wurden keine untergeordneten Nicht-Annotationselemente in <simpleType> gefunden. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen m\u00FCssen untergeordnete <restriction>-Elemente mit "base"-Attributen haben, die sich auf sich selbst beziehen.
src-redefine.5.a.b = src-redefine.5.a.b: "{0}" ist kein g\u00FCltiges untergeordnetes Element. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen m\u00FCssen untergeordnete <restriction>-Elemente mit "base"-Attributen haben, die sich auf sich selbst beziehen.
src-redefine.5.a.c = src-redefine.5.a.c: "{0}" hat kein "base"-Attribut, das sich auf das neu definierte Element "{1}" bezieht. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen m\u00FCssen untergeordnete <restriction>-Elemente mit "base"-Attributen haben, die sich auf sich selbst beziehen.
src-redefine.5.b.a = src-redefine.5.b.a: Es wurden keine untergeordneten Nicht-Annotationselemente in <complexType> gefunden. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen untergeordnete <extension>- oder <restriction>-Elemente mit "base"-Attributen haben, die sich auf sich selbst beziehen.
src-redefine.5.b.b = src-redefine.5.b.b: Es wurden keine auf zweiter Ebene untergeordneten Nicht-Annotationselemente in <complexType> gefunden. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen untergeordnete <extension>- oder <restriction>-Elemente mit "base"-Attributen haben, die sich auf sich selbst beziehen.
src-redefine.5.b.c = src-redefine.5.b.c: "{0}" ist kein g\u00FCltiges untergeordnetes Element der zweiten Ebene. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen untergeordnete <extension>- oder <restriction>-Elemente mit "base"-Attributen haben, die sich auf sich selbst beziehen.
src-redefine.5.b.d = src-redefine.5.b.d: "{0}" hat kein "base"-Attribut, das sich auf das neu definierte Element "{1}" bezieht. Untergeordnete <complexType>-Elemente von <redefine>-Elementen m\u00FCssen untergeordnete <extension>- oder <restriction>-Elemente mit "base"-Attributen haben, die sich auf sich selbst beziehen.
src-redefine.6.1.1 = src-redefine.6.1.1:  Wenn ein untergeordnetes Gruppenelement eines <redefine>-Elements eine Gruppe enth\u00E4lt, die sich auf sich selbst bezieht, muss es genau 1 haben; dieses hat "{0}".
src-redefine.6.1.2 = src-redefine.6.1.2:  Bei der Gruppe "{0}", die eine Referenz auf eine Gruppe enth\u00E4lt, die neu definiert wird, muss "minOccurs" = "maxOccurs" = 1 sein.
src-redefine.6.2.1 = src-redefine.6.2.1: Es gibt keine Gruppe im neu definierten Schema, die den Namen "{0}" hat.
src-redefine.6.2.2 = src-redefine.6.2.2: Gruppe "{0}" schr\u00E4nkt die Gruppe, die sie neu definiert, nicht richtig ein; Constraint verletzt:  ''{1}''.
src-redefine.7.1 = src-redefine.7.1:  Wenn ein untergeordnetes attributeGroup-Element eines <redefine>-Elements eine attributeGroup enth\u00E4lt, die sich auf sich selbst bezieht, muss es genau 1 haben; dieses hat {0}.
src-redefine.7.2.1 = src-redefine.7.2.1: Es gibt keine attributeGroup im neu definierten Schema, die den Namen "{0}" hat.
src-redefine.7.2.2 = src-redefine.7.2.2: AttributeGroup "{0}" schr\u00E4nkt die attributeGroup, die sie neu definiert, nicht richtig ein; Constraint verletzt:  ''{1}''.
src-resolve = src-resolve: Der Name "{0}" kann nicht in eine "{1}"-Komponente aufgel\u00F6st werden.
src-resolve.4.1 = src-resolve.4.1: Fehler beim Aufl\u00F6sen der Komponente "{2}". Es wurde festgestellt, dass "{2}" keinen Namespace hat; Komponenten ohne Ziel-Namespace sind jedoch vom Schemadokument "{0}" aus nicht referenzierbar. Wenn "{2}" einen Namespace haben soll, muss evtl. ein Pr\u00E4fix angegeben werden. Wenn "{2}" keinen Namespace haben soll, muss "{0}''" ein "import"'' ohne ein "namespace"-Attribut hinzugef\u00FCgt werden.
src-resolve.4.2 = src-resolve.4.2: Fehler beim Aufl\u00F6sen der Komponente "{2}". Es wurde festgestellt, dass "{2}" im Namespace "{1}" enthalten ist; Komponenten aus diesem Namespace sind jedoch vom Schemadokument "{0}" aus nicht referenzierbar. Wenn der Namespace falsch ist, muss ggf. das Pr\u00E4fix von "{2}" ge\u00E4ndert werden. Wenn der Namespace richtig ist, muss "{0}" ein entsprechendes "import"-Tag hinzugef\u00FCgt werden.
src-simple-type.2.a = src-simple-type.2.a: Es wurde ein <restriction>-Element gefunden, das unter seinen [children] sowohl ein base [attribute] als auch ein <simpleType>-Element hat. Es ist jedoch nur eines erlaubt.
src-simple-type.2.b = src-simple-type.2.b: Es wurde ein <restriction>-Element gefunden, das unter seinen [children] weder ein base [attribute] noch ein <simpleType>-Element hat. Eines ist jedoch erforderlich.
src-simple-type.3.a = src-simple-type.3.a: Es wurde ein <list>-Element gefunden, das unter seinen [children] sowohl ein itemType [attribute] als auch ein <simpleType>-Element hat. Es ist jedoch nur eines erlaubt.
src-simple-type.3.b = src-simple-type.3.b: Es wurde ein <list>-Element gefunden, das unter seinen [children] weder ein itemType [attribute] noch ein <simpleType>-Element hat. Eines ist jedoch erforderlich.
src-single-facet-value = src-single-facet-value: Die Facette "{0}"'' ist mehrmals definiert.
src-union-memberTypes-or-simpleTypes = src-union-memberTypes-or-simpleTypes: Ein <union>-Element muss unter seinen [children] entweder ein nicht-leeres memberTypes [attribute] oder mindestens ein <simpleType>-Element haben.

# constraint valid (3.X.6)
ag-props-correct.2 = ag-props-correct.2: Fehler bei Attributgruppe "{0}".  Doppelte Attributverwendungen mit gleichem Namen und Ziel-Namespace angegeben.  Name des doppelten Attributs ist "{1}".
ag-props-correct.3 = ag-props-correct.3: Fehler bei Attributgruppe "{0}".  Zwei Attributdeklarationen ("{1}"'' und "{2}") haben Typen, die von der ID abgeleitet sind.
a-props-correct.2 = a-props-correct.2: Ung\u00FCltiger Constraint-Wert "{1}" in Attribut "{0}".
a-props-correct.3 = a-props-correct.3: Attribut "{0}" darf nicht "fixed" bzw. "default" verwenden, da "{''type definition''}" des Attributs die ID oder von der ID abgeleitet ist.
au-props-correct.2 = au-props-correct.2: In der Attributdeklaration von "{0}" wurde der Wert "{1}" vorgegeben. Wenn die Attributverwendung, die sich auf "{0}" bezieht, also ebenfalls eine "{''value constraint''}" hat, muss dies behoben werden und sein Wert muss "{1}" sein.
cos-all-limited.1.2 = cos-all-limited.1.2: Eine "All" Modellgruppe muss in einem Partikel mit "{''min occurs''}"="{''max occurs''}"=1 stehen, und dieses Partikel muss Teil eines Paars sein, das den "{''content type''}" einer komplexen Typdefinition bildet.
cos-all-limited.2 = cos-all-limited.2: Der "{''max occurs''}" eines Elements in einer "All" Modellgruppe muss 0 oder 1 sein. Der Wert "{0}" f\u00FCr Element "{1}" ist ung\u00FCltig.
cos-applicable-facets = cos-applicable-facets: Facette "{0}" wird von Typ {1} nicht erlaubt.
cos-ct-extends.1.1 = cos-ct-extends.1.1: Typ "{0}" wurde durch Erweiterung von Typ "{1}" abgeleitet.  Das Attribut "final" von "{1}" verbietet jedoch eine Ableitung durch Erweiterung.
cos-ct-extends.1.4.3.2.2.1.a = cos-ct-extends.1.4.3.2.2.1.a: Der Inhaltstyp eines abgeleiteten Typs und seiner Basis m\u00FCssen beide gemischt oder beide "nur Elemente" sein. Typ "{0}" ist nur ein Element, sein Basistyp ist es jedoch nicht.
cos-ct-extends.1.4.3.2.2.1.b = cos-ct-extends.1.4.3.2.2.1.b: Der Inhaltstyp eines abgeleiteten Typs und seiner Basis m\u00FCssen beide gemischt oder beide "nur Elemente" sein. Typ "{0}" ist gemischt, sein Basistyp ist es jedoch nicht.
cos-element-consistent = cos-element-consistent: Fehler bei Typ "{0}". Mehrere Elemente mit dem Namen "{1}" mit verschiedenen Typen erscheinen in der Modellgruppe.
cos-list-of-atomic = cos-list-of-atomic: In der Definition des Listentyps "{0}" ist Typ "{1}" ein ung\u00FCltiger Listenelementtyp, da er nicht atomar ist ("{1}" ist entweder ein Listentyp oder ein Vereinigungstyp, der eine Liste enth\u00E4lt).
cos-nonambig = cos-nonambig: {0} und {1} (oder Elemente aus ihrer Ersatzgruppe) verletzen die "Unique Particle Attribution". Bei der Verletzung gegen dieses Schema w\u00FCrde bei diesen beiden Partikel Ambiguit\u00E4t entstehen.
cos-particle-restrict.a = cos-particle-restrict.a: Abgeleitetes Partikel ist leer und Basis ist nicht leerbar.
cos-particle-restrict.b = cos-particle-restrict.b: Basispartikel ist leer, abgeleitetes Partikel ist jedoch nicht leer.
cos-particle-restrict.2 = cos-particle-restrict.2: Verbotene Partikeleinschr\u00E4nkung: ''{0}''.
cos-st-restricts.1.1 = cos-st-restricts.1.1: Der Typ "{1}" ist atomar; seine "{''base type definition''}" ("{0}") muss also eine atomare einfache Typdefinition oder ein vordefinierter primitiver Datentyp sein.
cos-st-restricts.2.1 = cos-st-restricts.2.1: In der Definition des Listentyps "{0}" ist Typ "{1}" ein ung\u00FCltiger Elementtyp, da er entweder ein Listentyp oder ein Vereinigungstyp ist, der eine Liste enth\u00E4lt.
cos-st-restricts.2.3.1.1 = cos-st-restricts.2.3.1.1: Die Komponente "{''final''}" der "{''item type definition''}" ("{0}") enth\u00E4lt "list". Das bedeutet, dass "{0}" nicht als Elementtyp f\u00FCr Listentyp "{1}" verwendet werden kann.
cos-st-restricts.3.3.1.1 = cos-st-restricts.3.3.1.1: Die Komponente "{''final''}" der "{''member type definitions''}" ("{0}") enth\u00E4lt "union". Das bedeutet, dass "{0}" nicht als Membertyp f\u00FCr Vereinigungstyp "{1}" verwendet werden kann.
cos-valid-default.2.1 = cos-valid-default.2.1: Element "{0}" hat ein Wert-Constraint und muss ein gemischtes oder einfaches Inhaltsmodell haben.
cos-valid-default.2.2.2 = cos-valid-default.2.2.2: Da Element "{0}" ein "{''value constraint''}" und seine Typdefinition einen gemischten "{''content type''}" hat, muss das Partikel des "{''content type''}" leerbar sein.
c-props-correct.2 = c-props-correct.2: Kardinalit\u00E4t von Feldern f\u00FCr keyref "{0}" und key "{1}" muss\u00FCbereinstimmen.
ct-props-correct.3 = ct-props-correct.3: Zirkeldefinitionen f\u00FCr komplexen Typ "{0}" entdeckt. Das bedeutet, dass "{0}" in seiner eigenen Typhierarchie enthalten ist, was ein Fehler ist.
ct-props-correct.4 = ct-props-correct.4: Fehler bei Typ "{0}". Doppelte Attributverwendungen mit gleichem Namen und Ziel-Namespace angegeben.  Name der doppelten Attributverwendung ist "{1}".
ct-props-correct.5 = ct-props-correct.5: Fehler bei Typ "{0}". Zwei Attributdeklarationen ("{1}"'' und "{2}") haben Typen, die von der ID abgeleitet sind.
derivation-ok-restriction.1 = derivation-ok-restriction.1: Typ "{0}" wurde durch Einschr\u00E4nkung von Typ "{1}" abgeleitet.   "{1}" hat jedoch eine Eigenschaft "{''final''}", die eine Ableitung durch Einschr\u00E4nkung verbietet.
derivation-ok-restriction.2.1.1 = derivation-ok-restriction.2.1.1: Fehler bei Typ "{0}".  Die Attributverwendung "{1}" bei diesem Typ hat den "use"-Wert "{2}", der mit dem "required"-Wert einer entsprechenden Attributverwendung im Basistyp nicht konsistent ist.
derivation-ok-restriction.2.1.2 = derivation-ok-restriction.2.1.2: Fehler bei Typ "{0}".  Die Attributverwendung "{1}" in diesem Typ hat Typ "{2}", der vom Typ der entsprechenden Attributverwendung im Basistyp ("{3}") nicht g\u00FCltig abgeleitet wurde.
derivation-ok-restriction.2.1.3.a = derivation-ok-restriction.2.1.3.a: Fehler bei Typ "{0}".  Die Attributverwendung "{1}" in diesem Typ hat ein effektives Wert-Constraint, das nicht vorgegeben ist; das effektive Wert-Constraint der entsprechenden Attributverwendung im Basistyp ist vorgegeben.
derivation-ok-restriction.2.1.3.b = derivation-ok-restriction.2.1.3.b: Fehler bei Typ "{0}".  Die Attributverwendung "{1}" in diesem Typ hat ein effektives Wert-Constraint, das mit dem Wert "{2}" vorgegeben ist, jedoch mit dem Wert "{3}" f\u00FCr das vorgegebene effektive Wert-Constraint der entsprechenden Attributverwendung im Basistyp nicht konsistent ist.
derivation-ok-restriction.2.2.a = derivation-ok-restriction.2.2.a: Fehler bei Typ "{0}".  Die Attributverwendung "{1}" in diesem Typ hat keine entsprechende Attributverwendung in der Basis und der Basistyp hat kein Platzhalterattribut.
derivation-ok-restriction.2.2.b = derivation-ok-restriction.2.2.b: Fehler bei Typ "{0}".  Die Attributverwendung "{1}" in diesem Typ hat keine entsprechende Attributverwendung in der Basis und der Platzhalter im Basistyp erlaubt den Namespace "{2}" dieser Attributverwendung nicht.
derivation-ok-restriction.3 = derivation-ok-restriction.3: Fehler bei Typ "{0}".  Die Attributverwendung "{1}" im Basistyp hat REQUIRED als "true", hat jedoch keine entsprechende Attributverwendung im abgeleiteten Typ.
derivation-ok-restriction.4.1 = derivation-ok-restriction.4.1: Fehler bei Typ "{0}".  Die Ableitung hat einen Attributplatzhalter, die Basis hat jedoch keinen.
derivation-ok-restriction.4.2 = derivation-ok-restriction.4.2: Fehler bei Typ "{0}".  Der Platzhalter in der Ableitung ist kein g\u00FCltiges Platzhalter-Subset des Subsets in der Basis.
derivation-ok-restriction.4.3 = derivation-ok-restriction.4.3: Fehler bei Typ "{0}".  Der Prozessinhalt des Platzhalters in der Ableitung ({1}) ist schw\u00E4cher als der in der Basis ({2}).
derivation-ok-restriction.5.2.2.1 = derivation-ok-restriction.5.2.2.1: Fehler bei Typ "{0}".  Der einfache Inhaltstyp dieses Typs ("{1}") ist keine g\u00FCltige Einschr\u00E4nkung des einfachen Inhaltstyps der Basis ("{2}}.
derivation-ok-restriction.5.3.2 = derivation-ok-restriction.5.3.2: Fehler bei Typ "{0}".  Der Inhaltstyp dieses Typs ist leer, der Inhaltstyp der Basis ("{1}") ist jedoch nicht leer oder leerbar.
derivation-ok-restriction.5.4.1.2 = derivation-ok-restriction.5.4.1.2: Fehler bei Typ "{0}".  Der Inhaltstyp dieses Typs ist gemischt, der Inhaltstyp der Basis ("{1}") ist es jedoch nicht.
derivation-ok-restriction.5.4.2 = derivation-ok-restriction.5.4.2: Fehler bei Typ "{0}".  Das Partikel des Typs ist keine g\u00FCltige Einschr\u00E4nkung des Partikels der Basis.
enumeration-required-notation = enumeration-required-notation: Der NOTATION-Typ ("{0}"), der von {2} "{1}" verwendet wird, muss einen Enumerationsfacettenwert haben, der die von diesem Typ verwendeten Notationselemente spezifiziert.
enumeration-valid-restriction = enumeration-valid-restriction: Enumerationswert "{0}" ist nicht im Wertraum des Basistyps {1} enthalten.
e-props-correct.2 = e-props-correct.2: Ung\u00FCltiger Constraint-Wert "{1}" in Element "{0}".
e-props-correct.4 = e-props-correct.4: "{''type definition''}" f\u00FCr das Element "{0}" ist von der "{''type definition''}" des substitutionHead "{1}" nicht g\u00FCltig abgeleitet oder die Eigenschaft "{''substitution group exclusions''}" von "{1}" erlaubt diese Ableitung nicht.
e-props-correct.5 = e-props-correct.5: Element "{0}" darf "{''value constraint''}" nicht enthalten, da "{''type definition''}" oder "{''content type''}" der "{''type definition''}" des Elements die ID ist oder von der ID abgeleitet ist.
e-props-correct.6 = e-props-correct.6: Zirkel-Ersatzgruppe f\u00FCr Element "{0}" entdeckt.
fractionDigits-valid-restriction = fractionDigits-valid-restriction: In der Definition von {2} ist der Wert "{0}" f\u00FCr die Facette "fractionDigits" ung\u00FCltig, da er <= dem Wert f\u00FCr "fractionDigits" sein muss, der in einem der Vorg\u00E4ngertypen auf "{1}" gesetzt wurde.
fractionDigits-totalDigits = fractionDigits-totalDigits: In der Definition von {2} ist der Wert "{0}" f\u00FCr die Facette "fractionDigits" ung\u00FCltig, da der Wert <= dem Wert f\u00FCr "totalDigits" sein muss, der "{1}" ist.
length-minLength-maxLength.1.1 = length-minLength-maxLength.1.1: Bei Typ {0} ist es ein Fehler, wenn der Wert f\u00FCr length "{1}" kleiner als der Wert f\u00FCr minLength "{2}" ist.
length-minLength-maxLength.1.2.a = length-minLength-maxLength.1.2.a: Bei Typ {0} ist eine fehlende minLength-Facette f\u00FCr die Basis ein Fehler, wenn die aktuelle Einschr\u00E4nkung die minLength-Facette und die aktuelle Einschr\u00E4nkung oder Basis die length-Facette hat. 
length-minLength-maxLength.1.2.b = length-minLength-maxLength.1.2.b: Bei Typ {0} ist es ein Fehler, wenn die aktuelle minLength "{1}" nicht gleich der minLength "{2}" der Basis ist.
length-minLength-maxLength.2.1 = length-minLength-maxLength.2.1: Bei Typ {0} ist es ein Fehler, wenn der Wert f\u00FCr length "{1}" gr\u00F6\u00DFer als der Wert f\u00FCr maxLength "{2}" ist. 
length-minLength-maxLength.2.2.a = length-minLength-maxLength.2.2.a: Bei Typ {0} ist eine fehlende maxLength-Facette f\u00FCr die Basis ein Fehler, wenn die aktuelle Einschr\u00E4nkung die maxLength-Facette und die aktuelle Einschr\u00E4nkung oder Basis die length-Facette hat. 
length-minLength-maxLength.2.2.b = length-minLength-maxLength.2.2.b: Bei Typ {0} ist es ein Fehler, wenn die aktuelle maxLength "{1}" nicht gleich der maxLength "{2}" der Basis ist.        
length-valid-restriction = length-valid-restriction: Fehler bei Typ "{2}". Der Wert f\u00FCr length = "{0}" muss gleich dem Wert der L\u00E4nge des Basistyps "{1}" sein.
maxExclusive-valid-restriction.1 = maxExclusive-valid-restriction.1: Fehler bei Typ "{2}". Der maxExclusive-Wert ="{0}" muss <= maxExclusive des Basistyps "{1}" sein.
maxExclusive-valid-restriction.2 = maxExclusive-valid-restriction.2: Fehler bei Typ "{2}". Der maxExclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
maxExclusive-valid-restriction.3 = maxExclusive-valid-restriction.3: Fehler bei Typ "{2}". Der maxExclusive-Wert ="{0}" muss > minInclusive des Basistyps "{1}" sein.
maxExclusive-valid-restriction.4 = maxExclusive-valid-restriction.4: Fehler bei Typ "{2}". Der maxExclusive-Wert ="{0}" muss > minExclusive des Basistyps "{1}" sein.
maxInclusive-maxExclusive = maxInclusive-maxExclusive: "maxInclusive" und "maxExclusive" k\u00F6nnen nicht f\u00FCr den gleichen Datentyp festgelegt werden. In {2} ist maxInclusive = "{0}" und maxExclusive = "{1}".
maxInclusive-valid-restriction.1 = maxInclusive-valid-restriction.1: Fehler bei Typ "{2}". Der maxInclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
maxInclusive-valid-restriction.2 = maxInclusive-valid-restriction.2: Fehler bei Typ "{2}". Der maxInclusive-Wert ="{0}" muss < maxExclusive des Basistyps "{1}" sein.
maxInclusive-valid-restriction.3 = maxInclusive-valid-restriction.3: Fehler bei Typ "{2}". Der maxInclusive-Wert ="{0}" muss >= minInclusive des Basistyps "{1}" sein.
maxInclusive-valid-restriction.4 = maxInclusive-valid-restriction.4: Fehler bei Typ "{2}". Der maxInclusive-Wert ="{0}" muss > minExclusive des Basistyps "{1}" sein.
maxLength-valid-restriction = maxLength-valid-restriction: In der Definition von {2} muss der maxLength-Wert = "{0}" <= dem Wert des Basistyps "{1}" sein.
mg-props-correct.2 = mg-props-correct.2: Zirkeldefinitionen f\u00FCr Gruppe "{0}" entdeckt. Wird den "{''term''}"-Werten der Partikel rekursiv gefolgt, f\u00FChrt dies zu einem Partikel, bei dem "{''term''}" die Gruppe selbst ist.
minExclusive-less-than-equal-to-maxExclusive = minExclusive-less-than-equal-to-maxExclusive: In der Definition von {2} muss der minExclusive-Wert = "{0}" <= maxExclusive-Wert = "{1}" sein.
minExclusive-less-than-maxInclusive = minExclusive-less-than-maxInclusive: In der Definition von {2} muss der minExclusive-Wert = "{0}" < maxInclusive-Wert = "{1}" sein.
minExclusive-valid-restriction.1 = minExclusive-valid-restriction.1: Fehler bei Typ "{2}". Der minExclusive-Wert ="{0}" muss >= minExclusive des Basistyps "{1}" sein.
minExclusive-valid-restriction.2 = minExclusive-valid-restriction.2: Fehler bei Typ "{2}". Der minExclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
minExclusive-valid-restriction.3 = minExclusive-valid-restriction.3: Fehler bei Typ "{2}". Der minExclusive-Wert ="{0}" muss >= minInclusive des Basistyps "{1}" sein.
minExclusive-valid-restriction.4 = minExclusive-valid-restriction.4: Fehler bei Typ "{2}". Der minExclusive-Wert ="{0}" muss < maxExclusive des Basistyps "{1}" sein.
minInclusive-less-than-equal-to-maxInclusive = minInclusive-less-than-equal-to-maxInclusive: In der Definition von {2} muss der minInclusive-Wert = "{0}" <= maxInclusive-Wert = "{1}" sein.
minInclusive-less-than-maxExclusive = minInclusive-less-than-maxExclusive: In der Definition von {2} muss der minInclusive-Wert = "{0}" < maxExclusive-Wert = "{1}" sein.
minInclusive-minExclusive = minInclusive-minExclusive: "minInclusive" und "minExclusive" k\u00F6nnen nicht f\u00FCr den gleichen Datentyp festgelegt werden. In {2} ist minInclusive = "{0}" und minExclusive = "{1}".
minInclusive-valid-restriction.1 = minInclusive-valid-restriction.1: Fehler bei Typ "{2}". Der minInclusive-Wert ="{0}" muss >= minInclusive des Basistyps "{1}" sein.
minInclusive-valid-restriction.2 = minInclusive-valid-restriction.2: Fehler bei Typ "{2}". Der minInclusive-Wert ="{0}" muss <= maxInclusive des Basistyps "{1}" sein.
minInclusive-valid-restriction.3 = minInclusive-valid-restriction.3: Fehler bei Typ "{2}". Der minInclusive-Wert ="{0}" muss > minExclusive des Basistyps "{1}" sein.
minInclusive-valid-restriction.4 = minInclusive-valid-restriction.4: Fehler bei Typ "{2}". Der minInclusive-Wert ="{0}" muss < maxExclusive des Basistyps "{1}" sein.
minLength-less-than-equal-to-maxLength = minLength-less-than-equal-to-maxLength: In der Definition von {2} muss der minLength-Wert = "{0}" < maxLength-Wert = "{1}" sein.
minLength-valid-restriction = minLength-valid-restriction: In der Definition von {2} muss minLength = "{0}" >= dem Wert des Basistyps "{1}" sein.
no-xmlns = no-xmlns: Der {name} einer Attributdeklaration darf nicht "xmlns" entsprechen.
no-xsi = no-xsi: Der \u201e{''target namespace''}\u201c einer Attributdeklaration darf nicht \u201e{0}\u201c entsprechen.
p-props-correct.2.1 = p-props-correct.2.1: In der Deklaration von "{0}" ist der Wert von "minOccurs" = "{1}", er darf jedoch nicht gr\u00F6\u00DFer als der Wert von "maxOccurs" ("{2}") sein.
rcase-MapAndSum.1 = rcase-MapAndSum.1: Zwischen den Partikeln besteht keine vollst\u00E4ndige funktionale Zuordnung.
rcase-MapAndSum.2 = rcase-MapAndSum.2: Der Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
rcase-NameAndTypeOK.1 = rcase-NameAndTypeOK.1: Elemente haben Namen und Ziel-Namespaces, die nicht gleich sind:  Element "{0}" in Namespace "{1}" und Element "{2}" in Namespace "{3}".
rcase-NameAndTypeOK.2 = rcase-NameAndTypeOK.2: Fehler beim Partikel, bei dem "{''term''}" die Elementdeklaration "{0}" ist. "{''nillable''}" der Elementdeklaration ist "true", das entsprechende Partikel im Basistyp hat jedoch eine Elementdeklaration, bei der "{''nillable''}" "false" ist.
rcase-NameAndTypeOK.3 = rcase-NameAndTypeOK.3: Fehler beim Partikel, bei dem "{''term''}" die Elementdeklaration "{0}" ist. Sein Vorkommensbereich ({1},{2}) ist keine g\u00FCltige Einschr\u00E4nkung des Bereichs ({3},{4} des entsprechenden Partikels im Basistyp.
rcase-NameAndTypeOK.4.a = rcase-NameAndTypeOK.4.a: Element "{0}" ist nicht vorgegeben, das entsprechende Element im Basistyp ist jedoch mit Wert "{1}" vorgegeben.
rcase-NameAndTypeOK.4.b = rcase-NameAndTypeOK.4.b: Element "{0}" ist mit Wert "{1}" vorgegeben, das entsprechende Element im Basistyp ist jedoch mit Wert "{2}" vorgegeben.
rcase-NameAndTypeOK.5 = rcase-NameAndTypeOK.5: ID-Constraints f\u00FCr Element "{0}" sind kein Subset der ID-Constraints in der Basis.
rcase-NameAndTypeOK.6 = rcase-NameAndTypeOK.6: Die nicht erlaubten Ersetzungen f\u00FCr Element "{0}" sind kein Superset der Ersetzungen in der Basis.
rcase-NameAndTypeOK.7 = rcase-NameAndTypeOK.7: Der Typ des Elements "{0}" ("{1}") ist nicht vom Typ des Basiselements "{2}" abgeleitet.
rcase-NSCompat.1 = rcase-NSCompat.1: Element "{0}" hat einen Namespace "{1}", der durch den Platzhalter in der Basis nicht erlaubt ist.
rcase-NSCompat.2 = rcase-NSCompat.2: Fehler beim Partikel, bei dem "{''term''}" die Elementdeklaration "{0}" ist. Sein Vorkommensbereich ({1},{2}) ist keine g\u00FCltige Einschr\u00E4nkung des Bereichs ({3},{4} des entsprechenden Partikels im Basistyp.
rcase-NSRecurseCheckCardinality.1 = rcase-NSRecurseCheckCardinality.1: Zwischen den Partikeln besteht keine vollst\u00E4ndige funktionale Zuordnung.
rcase-NSRecurseCheckCardinality.2 = rcase-NSRecurseCheckCardinality.2: Der Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Platzhalterbereichs der Basis ({2},{3}).
rcase-NSSubset.1 = rcase-NSSubset.1: Platzhalter ist kein Subset des entsprechenden Platzhalters in der Basis.
rcase-NSSubset.2 = rcase-NSSubset.2: Vorkommensbereich des Platzhalters ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Bereichs in der Basis ({2},{3}).
rcase-NSSubset.3 = rcase-NSSubset.3: Prozessinhalt des Platzhalters "{0}" ist schw\u00E4cher als in der Basis "{1}".
rcase-Recurse.1 = rcase-Recurse.1: Der Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
rcase-Recurse.2 = rcase-Recurse.2: Zwischen den Partikeln besteht keine vollst\u00E4ndige funktionale Zuordnung.
rcase-RecurseLax.1 = rcase-RecurseLax.1: Der Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
rcase-RecurseLax.2 = rcase-RecurseLax.2: Zwischen den Partikeln besteht keine vollst\u00E4ndige funktionale Zuordnung.
rcase-RecurseUnordered.1 = rcase-RecurseUnordered.1: Der Vorkommensbereich der Gruppe ({0},{1}) ist keine g\u00FCltige Einschr\u00E4nkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
rcase-RecurseUnordered.2 = rcase-RecurseUnordered.2: Zwischen den Partikeln besteht keine vollst\u00E4ndige funktionale Zuordnung.

# We're using sch-props-correct.2 instead of the old src-redefine.1
# src-redefine.1 = src-redefine.1: The component ''{0}'' is begin redefined, but its corresponding component isn''t in the schema document being redefined (with namespace ''{2}''), but in a different document, with namespace ''{1}''.
sch-props-correct.2 = sch-props-correct.2: Ein Schema darf nicht zwei globale Komponenten mit dem gleichen Namen enthalten; dieses Schema enth\u00E4lt zwei Vorkommen von "{0}".
st-props-correct.2 = st-props-correct.2: Zirkeldefinitionen bei einfachem Typ "{0}" entdeckt. Das bedeutet, dass "{0}" in seiner eigenen Typhierarchie enthalten ist, was ein Fehler ist.
st-props-correct.3 = st-props-correct.3: Fehler bei Typ "{0}". Der Wert "{''final''}" der "{''base type definition''}" ("{1}") erlaubt die Ableitung durch Einschr\u00E4nkung nicht.
totalDigits-valid-restriction = totalDigits-valid-restriction: In der Definition von {2} ist der Wert "{0}" f\u00FCr die Facette "totalDigits" ung\u00FCltig, da er <= dem Wert f\u00FCr "totalDigits" sein muss, der in einem der Vorg\u00E4ngertypen auf "{1}" gesetzt wurde.
whiteSpace-valid-restriction.1 = whiteSpace-valid-restriction.1: In der Definition von {0} ist der Wert "{1}" f\u00FCr die Facette "whitespace" ung\u00FCltig, da der Wert f\u00FCr "whitespace" in einem der Vorg\u00E4ngertypen auf "collapse" gesetzt wurde.
whiteSpace-valid-restriction.2 = whiteSpace-valid-restriction.2: In der Definition von {0} ist der Wert "preserve" f\u00FCr die Facette "whitespace" ung\u00FCltig, da der Wert f\u00FCr "whitespace" in einem der Vorg\u00E4ngertypen auf "replace" gesetzt wurde.

# schema for Schemas
s4s-att-invalid-value = s4s-att-invalid-value: Ung\u00FCltiger Attributwert f\u00FCr "{1}" in Element "{0}". Aufgezeichnete Ursache: {2}
s4s-att-must-appear = s4s-att-must-appear: Attribut \u201e{1}\u201c muss im Element \u201e{0}\u201c stehen.
s4s-att-not-allowed = s4s-att-not-allowed: Attribut \u201e{1}\u201c kann nicht im Element \u201e{0}\u201c stehen.
s4s-elt-invalid = s4s-elt-invalid: Element "{0}" ist in einem Schemadokument kein g\u00FCltiges Element.
s4s-elt-must-match.1 = s4s-elt-must-match.1: Der Inhalt von "{0}" muss "{1}" entsprechen. Problem ab folgender Stelle gefunden: {2}.
s4s-elt-must-match.2 = s4s-elt-must-match.2: Der Inhalt von "{0}" muss "{1}" entsprechen. Nicht gen\u00FCgend Elemente gefunden.

# the "invalid-content" messages provide less information than the "must-match" counterparts above. They're used for complex types when providing a "match" would be an information dump
s4s-elt-invalid-content.1 = s4s-elt-invalid-content.1: Der Inhalt von "{0}" ist ung\u00FCltig.  Element "{1}" ist ung\u00FCltig, falsch platziert oder kommt zu h\u00E4ufig vor.
s4s-elt-invalid-content.2 = s4s-elt-invalid-content.2: Der Inhalt von "{0}" ist ung\u00FCltig.  Element "{1}" darf nicht leer sein.
s4s-elt-invalid-content.3 = s4s-elt-invalid-content.3: Elemente des Typs "{0}" d\u00FCrfen nach Deklarationen nicht als untergeordnete Elemente eines <schema>-Elements erscheinen.
s4s-elt-schema-ns = s4s-elt-schema-ns: Der Namespace des Elements "{0}" muss aus dem Schema-Namespace "http://www.w3.org/2001/XMLSchema" stammen.
s4s-elt-character = s4s-elt-character: Nicht-Leerraumzeichen sind nur in den Schemaelementen "xs:appinfo" und "xs:documentation" erlaubt. "{0}" gesehen.

# codes not defined by the spec
c-fields-xpaths = c-fields-xpaths: Der Feldwert = "{0}" ist nicht g\u00FCltig.
c-general-xpath = c-general-xpath: Der Ausdruck "{0}" ist im Hinblick auf das vom XML-Schema unterst\u00FCtzte XPath-Subset nicht g\u00FCltig.
c-general-xpath-ns = c-general-xpath-ns: Ein Namespace-Pr\u00E4fix im XPath-Ausdruck "{0}" wurde nicht an einen Namespace gebunden.
c-selector-xpath = c-selector-xpath: Der Selektorwert = "{0}" ist nicht g\u00FCltig; Selektor-xpaths k\u00F6nnen keine Attribute enthalten.
EmptyTargetNamespace = EmptyTargetNamespace: Der Wert des Attributs "targetNamespace"'' im Schemadokument "{0}" darf keine leere Zeichenkette sein.
FacetValueFromBase = FacetValueFromBase: In der Deklaration des Typs "{0}" muss der Wert "{1}''" der Facette "{2}" im Wertraum des Basistyps "{3}" enthalten sein.
FixedFacetValue = FixedFacetValue: In der Definition von {3} ist der Wert "{1}" f\u00FCr die Facette "{0}" ung\u00FCltig, da der Wert f\u00FCr "{0}" in einem der Vorg\u00E4ngertypen auf "{2}" gesetzt wurde und "{''fixed''}" = true ist.
InvalidRegex = InvalidRegex: Musterwert "{0}" ist kein g\u00FCltiger regul\u00E4rer Ausdruck. Der gemeldete Fehler war: ''{1}''.
maxOccurLimit = Die aktuelle Konfiguration des Parsers erlaubt es nicht, ein Inhaltsmodell f\u00FCr einen komplexen Typ zu erweitern, sodass es mehr als {0} Knoten enth\u00E4lt.
PublicSystemOnNotation = PublicSystemOnNotation: Im Element "notation" muss mindestens ein "public" und "system" stehen.
SchemaLocation = SchemaLocation: schemaLocation-Wert = "{0}" muss eine gerade URI-Anzahl haben.
TargetNamespace.1 = TargetNamespace.1: Namensraum \u201e{0}\u201c erwartet, aber der Ziel-Namensraum des Schemadokuments ist \u201e{1}\u201c.
TargetNamespace.2 = TargetNamespace.2: Keinen Namespace erwartet, das Schemadokument hat jedoch den Ziel-Namespace "{1}".
UndeclaredEntity = UndeclaredEntity: Entit\u00e4t \u201e{0}\u201c'' ist nicht deklariert.
UndeclaredPrefix = UndeclaredPrefix: \u201e{0}\u201c kann nicht als QName aufgel\u00f6st werden: das Pr\u00e4fix \u201e{1}\u201c ist nicht deklariert.

# JAXP 1.2 schema source property errors
jaxp12-schema-source-type.1 = Die Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" darf keinen Wert des Typs "{0}" haben. M\u00F6gliche unterst\u00FCtzte Typen f\u00FCr den Wert sind String, File, InputStream, InputSource bzw. ein Array dieser Typen.
jaxp12-schema-source-type.2 = Die Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" darf keinen Arraywert des Typs "{0}" haben. M\u00F6gliche unterst\u00FCtzte Typen f\u00FCr Arrays sind Object, String, File, InputStream und InputSource.
jaxp12-schema-source-ns = Wenn als Wert der Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" ein Array von Objekten verwendet wird, ist es nicht zul\u00E4ssig, dass zwei Schemas den gleichen Ziel-Namespace zu haben.
