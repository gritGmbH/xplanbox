[uwsgi]
;https://www.bloomberg.com/company/stories/configuring-uwsgi-production-deployment/
;strict = true
pyargv = /srv/mapproxy/mapproxy.yaml
mount = /$(XPLAN_MAPPROXY_PATH)=app.py
manage-script-name = true
virtualenv = /srv/mapproxy/venv
pidfile = /tmp/mapproxy.pid
http-socket = 0.0.0.0:8080
processes = $(XPLAN_MAPPROXY_MAXPROC)             ; Maximum number of workers allowed
cheaper = $(XPLAN_MAPPROXY_MINPROC)                 ; Minimum number of workers allowed
enable-threads = true
threads = $(XPLAN_MAPPROXY_THREADS)
master = true
vacuum = true
die-on-term = true                   ; Shutdown when receiving SIGTERM (default is respawn)
need-app = true
max-requests = 1000                  ; Restart workers after this many requests
max-worker-lifetime = 3600           ; Restart workers after this many seconds
reload-on-as = 1024
reload-on-rss = 512
worker-reload-mercy = 60             ; How long to wait before forcefully killing workers
;wsgi-disable-file-wrapper = true
harakiri = 60
py-callos-afterfork = true           ; allow workers to trap signals
cheaper-algo = busyness
cheaper-initial = $(XPLAN_MAPPROXY_MINPROC)                ; Workers created at startup
cheaper-overload = 1                 ; Length of a cycle in seconds
cheaper-step = $(XPLAN_MAPPROXY_MINPROC)                    ; How many workers to spawn at a time
cheaper-busyness-multiplier = 30     ; How many cycles to wait before killing workers
cheaper-busyness-min = 20            ; Below this threshold, kill workers (if stable for multiplier cycles)
cheaper-busyness-max = 70            ; Above this threshold, spawn new workers
cheaper-busyness-backlog-alert = $(XPLAN_MAPPROXY_MINPROC)  ; Spawn emergency workers if more than this many requests are waiting in the queue
cheaper-busyness-backlog-step = 2    ; How many emergency workers to create if there are too many requests in the queue
uid = 1001
gid = 1001
http-uid = 1001
http-gid = 1001
disable-logging = true
log-4xx = true
log-5xx = true
single-interpreter = true
;thunder-lock = true
stats = 0.0.0.0:9000
stats-http = true
log-encoder = format {"time": "${strftime:%%Y-%%m-%%dT%%H:%%M:%%S %%z}", "message": "${msg}"}
log-encoder = nl